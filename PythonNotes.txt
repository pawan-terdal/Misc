Expressions = Values + Operators
	Reduce to single values

+ = Concatenation Operator
	print("Hello " + "World")
* = String repetition operator
	print("Hello" * 3)

# This is a single line comment

"""
This
is 
a 
multi 
line
comment
"""

len("Hello") #5 - Used to get length of a string
int(value) #Returns integer form of value
float(value) #Returns float
str(value) #Returns string
bool(value) #Returns bool
list(value) #Returns a list

True , False = Are Boolean Value

Comparison Operators : == , != , > , < , >= , <=
Logical Operators : and , or , not

if name == "Nithin" :
	print("Hello Nithin.")
elif name == "Bubbles" :
	print("Hello Bubbles.")
else :
	print("Hello User")


i = 0
while(i < 5):
	print(str(i))
	i += 1



for i in range(0,5,1): #5 is not included and 3rd argument is increment/decrement by.
	print(str(i))







import random
random.randint(1, 10) # Prints numbers between 1 and 10 both incl.



from random import *
randint(1, 10) # Can call without random object.



import sys
sys.exit() # Similar to exit in C++



def Hello(name) : #Defining a function.
	print("Hello " + name)

Every function in Python returns a value. By default it's "None" value.






Keyword Arguments
print("Hello", end="")







try :
	print(5/0)
except ZeroDivisionError :
	print("You divided by zero.")
except :
	print("ZZZ")









LISTS


	Begin and end with square braces.
a = [ 1 , 2 , 3 , 4 , 5 ]

a[1] # 2
a[-1] # 5 . Gives the last element.

a[1 : 4 : 2 ] = [ 2 , 4 ] #It doesn't include index 4. Goes till 3. The last thing is called the step value. By default it's 1.






To delete items in the list
	del a[1] # [ 1 , 3 , 4 ,5 ]
len(a) # 4 Length of list

List replication operator. Using '*'


2 in a # Returns False because it doesnt exist in 'a' list.

2 not in a # Returns True because it doesnt exist in 'a' list.


range(4) # range(0, 3). If we pass this to list(range(4)). Then we get back [0, 1, 2, 3]. Range is a list like value.


for i in range(len(someList)) : #Way to use range and len fn together.
	print("Hello")


Multiple assignment
	cat = ['fat', 'orange', 'loud']
	size, color, disposition = cat
	"""
	'fat' is assigned to size.
	'orange' is assigned to color.
	'loud' is assigned to disposition.
	"""
We can also do  something like this
	size, color, disposition = 'fat', 'orange', 'loud'
	#Does same thing as above.

Using multiple assignment for swapping

	a = 5
	b = 6
	a, b = b, a# Swaps the values.






Augmented assignment operators : += , -= , *= , /= , %=


 








METHODS

	Functions called on values.


List Methods ( NOTE LIST IS MUTUABLE TYPE )
	Let 'l' be a list

	l.index("Hello") # Returns index of the value. If not there it throws an exception.

	l.append("Cat") # Adds a value to the end of the list

	l.insert( 1 , "Dog") #Adds a value at index 1.

	l.remove("Bat") # Removes Bat from the list. Throws an error if not present. ONLY FIRST INSTANCE IS REMOVED.

	l.sort() # Sorts list in ASCII Betical Order.
	l.sort(reverse=True) # Sorts in reverse ASCII Betical order.
	#Cannot sort a list which has both string and integer values.
	l.sort(key=str.lower) # Sorts in TRUE Alphabetical Order.




SIMILARITIES between List and Strings

	List is a mutable data type.
	String is an immutable data type.
	List is a reference type.
	Strings and Tupples are immutable values. They aren't reference types.

	To copy a reference type. List.
	Let 'l' be a list
	import copy
	a = copy.deepcopy(l)

'\' is a line continuation character. Can be used to stretch python instructions to multiple lines.





DICTIONARY
	
	Has a key value pair.
	myCat = { 'size' : 'fat', 'color' : 'gray' }
	myCat['species']	
	#KeyError message is thrown if key not present.
	To check if a key exists use 'in' operator
	'size' in myCat #True
	
	list(myCat.keys())
	list(myCat.values())
	list(myCat.items())

for i , j in myCat.items() :
	print(i,j)

"""
size fat
color gray
"""


For it to not throw KeyError if key isn't present
Therefore .get() function.
Takes two parameters. One is key, Second is fallback default value that method returns.

l.setdefault('species','lol')
	Inserts the key value pair only if key doesn't exist.


To count frequency of letters in a message

count = {}
for i in message :
	count.setdefault(i, 0)
	count[i] += 1
  
#SINCE DICTIONARIES ARE UNORDERED.
#To do a pretty print
	import pprint
	pprint.pprint(count) #Prints the dictionary in a pretty way.
	s = pprint.pformat(count) # Stores the formatted output in a string 's'








ADVANCED STRING SYNTAX

Multi Line String ( Verbatim Strings )
	"""That is Alice's cat"""

Raw String (Removes the functionality of backslash - escaping)
	r'That is Alice's cat'

Can use slices , indexes , in and not in operators on strings ( list like values)




STRING METHODS ( IMMUTABLE THEREFORE THEY ALWAYS RETURN A NEW STRING)

upper() : Returns a new string which is upper case.
lower() : Returns a new string which is lower case.
title() : Returns a new string which is title case.
isupper() : Returns a boolean value.
islower() : Returns a boolean value.

"""
isupper() and is islower() returns false if the string is empty.
"""

isalpha() - Letters only.
isalnum() - Letters and numbers only.
isdecimal() - Numbers only
isspace() - Whitespace only
istitle() - Title case only

startswith(value)
endswith(value)

To join a list of strings into one string with separator use.
','.join(['cats','bats','rats'])


To split a string into list of strings use.
.split(delimiter)


To justify a string use
rjust(length, fillcharacter) - Right justifies.
ljust(length, fillcharacter) - Left justifies.
center(length, fillcharacter) - Center justifies.


To strip off whitespaces
strip(character) - Remove whitespaces.
lstrip(character)
rstrip(character) 

To replace
replace(pattern string, replace string)



pyperclip.copy() - Copies whatever is passed into the function to the clipboard.





STRING FORMATTING/ INTERPOLATION

'Hello %s, I am %s' % (name1,name2)






#!/usr/bin/python3
import sys
The arguments passed to the program from outside can be accessed from
sys.argv #A list of strings

NOTE : The first argument is the path of the file itself





PATTERN MATCHING AND REGULAR EXPRESSIONS

import re # Regular expression functions.
phoneNumberRegex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d') #Creates a regular expression object.
mo = phoneNumberRegex.search(String)
mo = phoneNumberRegex.findall(String) #To find all occurances.
print(mo.group())

phoneNumberRegex = re.compile(r'(\d\d\d)-(\d\d\d-\d\d\d\d)')
mo = phoneNumberRegex.findall(String) #To find all occurances.
print(mo.group(1)) #Gives only area code.
print(mo.group(2)) #Gives rest of code.

To find strings which 
batRegex = re.compile(r'bat(mobile|man)') #Using pipe to match one of several patterns.
Finds either batmobile or batman




? - Match preceeding group either zero or one time.

re.compile(r'Bat(wo)?man') Searches for Batman or Batwoman

* - Match preceeding group either zero or more times.

+ - Match preceeding group either one or more times.

{x,y} - Match preceeding group atleast x times and utmost y times.
	Here by default it matches the longest possible string.
	Greedy match.

{x,y}? - To do a non greedy match.


Shorthand character classes
\d Numeric
\D not Numeric
\w Alpha numeric or underscore
\W not alpha numeric and underscore
\s Space tab or newline character
\S Any character not a space tab or newline.

To create user defined character classes
re.compile(r'[a-zA-Z]')
re.compile(r'[^a-zA-Z]') #Negative doesnt find alphabets

r'^Hello' - Should start with Hello.
r'world!$' - Should end with hello.

. - Any character occuring once EXCEPT NEWLINE.

To make '.' to truly represent Any character pass the "re.DOTALL" as second argument in re.compile(,)

"re.IGNORECASE" as second argument will ignore case

Substitute
namesRegex = re.compile(r'Agent (\w)w*')
namesRegex.sub(r'Agent \1****', 'Agent Alice gave the secret documents to Agent Bob')
'Agent A**** gave the secret documents to Agent B****'


re.VERBOSE
re.compile(r"""
\d\d\d
-
\d\d\d
-
\d\d\d\d""", re.VERBOSE)



import os
os.getcwd() # To get current working directory
os.path.* # Investigate
os.listdir()
os.makedirs()


open("filename") # Open's file in read mode
open("filename",'w') # Write mode
open("filename",'a') # Append mode

To store data in binary format to retrieve it later

import shelve
file = shelve.open('filename')
file['cats'] = ['ABC','XYZ']
file.close()

file = shelve.open('filename')
file['cats']


list(file.keys()) # Returns all the keys stored in the binary file.






FILE HANDLING

import shutil

shutil.copy()
shutil.copytree()
shutil.move() # Can use it to rename also.
shutil.


TO DELETE A FILENAME

import os
os.unlink("path") # To delete a single file.
os.rmdir("path") # Delete empty folder.

import shutil
shutil.rmtree("path") # To delete entire folder.


import send2trash
send2trash.send2trash("path") Send's to recycle bin.

How to walk through directories

import os
for folderName, subfolders, filenames in os.walk() :
	print(folderName)
	print(subfolders)
	print(filenames)


The throw keyword in python is 'raise'

import traceback
try :
	raise Exception('Random exception')
except :
	errorFile = open('errorlog.txt', 'a')
	errorFile.write(traceback.format_exc())
	errorFile.close()


Assert statements

assert <sanity condition> , <what to do if its false>




LOGGING

"""
Log levels
debug
info
warning
error
critical
"""
import logging
logging.basicConfig(level=logging.DEBUG, format = '%(asctime)s - %(levelname)s - %(message)s')
logging.disable(logging.CRITICAL) # Disables all critical and lower level log messages.
logging.debug("Message") # Similar to print function calls.


import webbrowser
webbrowser.open("URL HERE")

import requests
res = requests.get('URL here')
res.status_code #200 is a code to indicate evrything went okay.
res.raise_for_status()

After downloading
Open a file with binary mode
playFile = open('RomeoAndJuliet.txt','wb')
for chunk in res.iter_content(1000000):
	playFile.write(chunk)



